[
  {
    "Name": "setup",
    "Desc": "Function called once when the program begins running. Used to define initial enviroment properties such as a pin mode (INPUT or OUTPUT), starting the serial port etc. before the loop() begins executing. Variables declared within setup() are not accessible within loop().",
    "Syn": {
      "Syntax": "setup()",
      "Params": ["none"],
      "Return": " "
    },
    "Examples": ["void setup() {<br>&emsp;&nbsp;//your code here<br>}"],
    "Additional": ["loop"]
  },
  {
    "Name": "loop",
    "Desc": "Continuously executes the lines of code contained inside its block until the program is stopped. The loop() function is used in conjunction with setup(). The number of times loop() executes in each second may be controlled with the delay() and delayMicroseconds() functions.",
    "Syn": {
      "Syntax": "loop()",
      "Params": [" "],
      "Return": " "
    },
    "Examples": ["void loop() {<br>&emsp;&nbsp;//your code here<br>}"],
    "Additional": ["setup"]
  },
  {
    "Name": "if",
    "Desc": "Tests whether a certain expression has been verified, such as an input being above a certain number. If the expression evaluates to true, the statements enclosed within the block are executed and if the expression evaluates to false the statements are not executed.",
    "Syn": {
      "Syntax": "if (conditional) and ==, !=, <, > (comparison operators)",
      "Params": [" "],
      "Return": " "
    },
    "Examples": ["if (x > 120)<br>&emsp;&nbsp;digitalWrite(LEDpin, HIGH);"],
    "Additional": ["else","switchcase","Comparison+Operators"]
  },
  {
    "Name": "for",
    "Desc": "Is a control iteratively structure that determines the execution of a portion of the program repeated for a certain known number of times. The for statement is useful for any repetitive operation, and is often used in combination with arrays to operate on collections of data/pins.",
    "Syn": {
      "Syntax": "for (initialization; condition; increment) {",
      "Params": [" "],
      "Return": " "
    },
    "Examples": ["for (int i=0; i <= 255; i++) {<br>&emsp;&nbsp;analogWrite(PWMpin, i);<br>&emsp;&nbsp;delay(10);<br>} "],
    "Additional": ["While", "DoWhile"]
  },
  {
    "Name": "switch",
    "Desc": "Works like an if else structure, but is more conveniente when you need to select between three or more alternatives. Program controls jumps to the case with the same value as the expression. The break keyword exits the switch statement, and is typically used at the end of each case. Without it, the switch statement will continue executing the following expressions until a break, or the end of the switch statement is reached.",
    "Syn": {
      "Syntax": "switch (var) {<br>&emsp;&nbsp;case label:<br>&emsp;&nbsp;//code here<br>&emsp;&nbsp;break;<br>&emsp;&nbsp;default:<br>&emsp;&nbsp;//code here<br>}",
      "Params": [" "],
      "Return": " "
    },
    "Examples": [" "],
    "Additional": ["If","Else"]
  },
  {
    "Name": "while",
    "Desc": "The structure executes a series of statements continuously while the expression is true. The expression must be updated during the repetitions or the program will never 'break out' of while(). The statement can be an incremented variable, or an external condition.",
    "Syn": {
      "Syntax": "while(expression){<br>&emsp;&nbsp;//statement(s)<br>}",
      "Params": ["expression - a (boolean) C statement that evaluates to true or false"],
      "Return": " "
    },
    "Examples": ["var = 0;<br>while(var < 200) {&emsp;&nbsp;<br>// do something repetitive 200 times<br>&emsp;&nbsp;var++;<br>}"],
    "Additional": ["For","DoWhile"]
  },
  {
    "Name": "break",
    "Desc": "Ends the execution of a structure such as switch(), for(),do...while() or while() and jumps to the next statement after.",
    "Syn": {
      "Syntax": "break;",
      "Params": [" "],
      "Return": " "
    },
    "Examples": [" "],
    "Additional": ["For","SwitchCase","While"]
  },
  {
    "Name": "continue",
    "Desc": "The statement is used to skip the part of loop (do, for or while). It skips the remaining part of the loop and control again goes to check the condition again.",
    "Syn": {
      "Syntax": "continue;",
      "Params": [" "],
      "Return": " "
    },
    "Examples": [" "],
    "Additional": ["while","for","if"]
  },
  {
    "Name": "return",
    "Desc": "The return statement is used to terminate the execution of a function and return a value from the calling function. All that is after return, will never be executed.",
    "Syn": {
      "Syntax": "return;<br>return value;",
      "Params": ["value: any variable or constant type"],
      "Return": " "
    },
    "Examples": ["return 0;"],
    "Additional": [""]
  },
  {
    "Name": "goto",
    "Desc": "Transfers program flow to a label in the program.",
    "Syn": {
      "Syntax": "label: //your code here<br>goto label;",
      "Params": [" "],
      "Return": " "
    },
    "Examples": ["label:<br>&emsp;&nbsp;goto label;<br>&emsp;&nbsp;//sends program flow to the label"],
    "Additional": [" "]
  },
  {
    "Name": "HIGH",
    "Desc": "The meaning of HIGH (in reference to a pin) is somewhat different depending on whether a pin is set to an INPUT or OUTPUT. When a pin is configured as an INPUT with pinMode, and read with digitalRead, the Arduino (Atmega) will report HIGH if:a voltage greater than 3 volts is present at the pin (5V boards);a voltage greater than 2 volts is present at the pin (3.3V boards);A pin may also be configured as an INPUT with pinMode(), and subsequently made HIGH with digitalWrite(). This will enable the internal 20K pullup resistors, which will pull up the input pin to a HIGH reading unless it is pulled LOW by external circuitry. This is how INPUT_PULLUP works and is described below in more detail.<br>When a pin is configured to OUTPUT with pinMode, and set to HIGH with digitalWrite, the pin is at:5 volts (5V boards);<br>3.3 volts (3.3V boards);In this state it can source current, e.g. light an LED that is connected through a series resistor to ground, or to another pin configured as an output, and set to LOW.",
    "Syn": {
      "Syntax": " ",
      "Params": [" "],
      "Return": " "
    },
    "Examples": [" "],
    "Additional": ["pinMode","int","boolean"]
  },
  {
    "Name": "LOW",
    "Desc": "The meaning of LOW also has a different meaning depending on whether a pin is set to INPUT or OUTPUT. When a pin is configured as an INPUT with pinMode(), and read with digitalRead(), the Arduino (Atmega) will report LOW if::<br>a voltage less than 3 volts is present at the pin (5V boards);<br>a voltage less than 2 volts is present at the pin (3.3V boards); When a pin is configured to OUTPUT with pinMode(), and set to LOW with digitalWrite(), the pin is at 0 volts (both 5V and 3.3V boards). In this state it can sink current, e.g. light an LED that is connected through a series resistor to +5 volts (or +3.3 volts).",
    "Syn": {
      "Syntax": " ",
      "Params": [" "],
      "Return": " "
    },
    "Examples": [" "],
    "Additional": ["pinMode","int","boolean"]
  },
  {
    "Name": "INPUT",
    "Desc": "Arduino (Atmega) pins configured as INPUT with pinMode() are said to be in a high-impedance state. Pins configured as INPUT make extremely small demands on the circuit that they are sampling, equivalent to a series resistor of 100 Megohms in front of the pin. This makes them useful for reading a sensor.<br>If you have your pin configured as an INPUT, and are reading a switch, when the switch is in the open state the input pin will be \"floating\", resulting in unpredictable results. In order to assure a proper reading when the switch is open, a pull-up or pull-down resistor must be used. The purpose of this resistor is to pull the pin to a known state when the switch is open. A 10 K ohm resistor is usually chosen, as it is a low enough value to reliably prevent a floating input, and at the same time a high enough value to not not draw too much current when the switch is closed. See the Digital Read Serial tutorial for more information.<br>If a pull-down resistor is used, the input pin will be LOW when the switch is open and HIGH when the switch is closed.<br> If a pull-up resistor is used, the input pin will be HIGH when the switch is open and LOW when the switch is closed.",
    "Syn": {
      "Syntax": " ",
      "Params": [" "],
      "Return": " "
    },
    "Examples": [" "],
    "Additional": ["pinMode","int","boolean"]
  },
  {
    "Name": "INPUT_PULLUP",
    "Desc": "The Atmega microcontroller on the Arduino has internal pull-up resistors (resistors that connect to power internally) that you can access. If you prefer to use these instead of external pull-up resistors, you can use the INPUT_PULLUP argument in pinMode().<br>See the Input Pullup Serial tutorial for an example of this in use.<br> Pins configured as inputs with either INPUT or INPUT_PULLUP can be damaged or destroyed if they are connected to voltages below ground (negative voltages) or above the positive power rail (5V or 3V).",
    "Syn": {
      "Syntax": " ",
      "Params": [" "],
      "Return": " "
    },
    "Examples": [" "],
    "Additional": ["pinMode","int","boolean"]
  },
  {
    "Name": "OUTPUT",
    "Desc": "Pins configured as OUTPUT with pinMode() are said to be in a low-impedance state. This means that they can provide a substantial amount of current to other circuits. Atmega pins can source (provide current) or sink (absorb current) up to 40 mA (milliamps) of current to other devices/circuits. This makes them useful for powering LEDs because LEDs typically use less than 40 mA. Loads greater than 40 mA (e.g. motors) will require a transistor or other interface circuitry.<br> Pins configured as outputs can be damaged or destroyed if they are connected to either the ground or positive power rails. Defining built-ins: LED_BUILTIN<br> Most Arduino boards have a pin connected to an on-board LED in series with a resistor. The constant LED_BUILTIN is the number of the pin to which the on-board LED is connected. Most boards have this LED connected to digital pin 13.",
    "Syn": {
      "Syntax": " ",
      "Params": [" "],
      "Return": " "
    },
    "Examples": [" "],
    "Additional": ["pinMode","int","boolean"]
  },
  {
    "Name": "LED_BUILTIN",
    "Desc": "Most Arduino boards have a pin connected to an on-board LED in series with a resistor. LED_BUILTIN is a drop-in replacement for manually declaring this pin as a variable. Most boards have this LED connected to digital pin 13.",
    "Syn": {
      "Syntax": " ",
      "Params": [" "],
      "Return": " "
    },
    "Examples": [" "],
    "Additional": ["pinMode","int","boolean"]
  },
  {
    "Name": "false",
    "Desc": "false is the easier of the two to define. false is defined as 0 (zero).",
    "Syn": {
      "Syntax": " ",
      "Params": [" "],
      "Return": " "
    },
    "Examples": [" "],
    "Additional": ["pinMode","int","boolean"]
  },
  {
    "Name": "true",
    "Desc": "true is often said to be defined as 1, which is correct, but true has a wider definition. Any integer which is non-zero is true, in a Boolean sense. So -1, 2 and -200 are all defined as true, too, in a Boolean sense.<br>Note that the true and false constants are typed in lowercase unlike HIGH, LOW, INPUT, and OUTPUT.",
    "Syn": {
      "Syntax": " ",
      "Params": [" "],
      "Return": " "
    },
    "Examples": [" "],
    "Additional": ["pinMode","int","boolean"]
  },
  {
    "Name": "boolean",
    "Desc": "Datatype boolean defines two values: true and false. <br> The value false indicates the 0, true rapresents 1 or any different value than 0.",
    "Syn": {
      "Syntax": " ",
      "Params": [" "],
      "Return": " "
    },
    "Examples": [" "],
    "Additional": [" "]
  },
  {
    "Name": "pinMode",
    "Desc": "The pinMode() sets the specified digital I/O pin as INPUT or OUTPUT.<br> It is possible to set or read the value of a digital I/O pin by using the digitalWrite() and digitalRead() methods.",
    "Syn": {
      "Syntax": "pinMode(pin, mode);",
      "Params": ["pin: the number of the pin whose mode you wish to set<br>mode: INPUT, OUTPUT, or INPUT_PULLUP. (see the digital pins page for a more complete description of the functionality.)"],
      "Return": "None"
    },
    "Examples": ["int ledPin = 13;<br>pinMode(ledPin, OUTPUT);"],
    "Additional": ["Constants","digitalWrite","digitalRead"]
  },
  {
    "Name": "void",
    "Desc": "Void is used only when it is declarated a function and it indicates that for this functuion isn't expected a return value.",
    "Syn": {
      "Syntax": "void",
      "Params": [" "],
      "Return": " "
    },
    "Examples": ["void setup() {}"],
    "Additional": [" "]
  },
  {
    "Name": "char",
    "Desc": "The char type stores characters in the ASCII format.<br> You can initialize it inserting the char with single quotes or through the corrispodent number ASCII value.<br> Each char occupies one byte (8bits).<br> Char is a signed type then it encodes numbers from -128 to 127.",
    "Syn": {
      "Syntax": " ",
      "Params": [" "],
      "Return": " "
    },
    "Examples": ["char myChar = 'A';"],
    "Additional": ["unsignedChar","byte","array"]
  },
  {
    "Name": "byte",
    "Desc": "Byte type occupies one byte (8bits) and it stores numerical values from 0 to 255.",
    "Syn": {
      "Syntax": "A byte stores an 8-bit unsigned number, from 0 to 255.",
      "Params": [" "],
      "Return": " "
    },
    "Examples": ["byte b = B10010;"],
    "Additional": ["char","unsigned char","int","unsigned int","long","unsigned long","float","double","array","short"]
  },
  {
    "Name": "int",
    "Desc": "Datatype 'int' occupies two byte(16 bit)and it stores an integer number (number without a decimal point)between -32768 to 32767.<br> On the Arduino Due datatype 'int' occupies four byte (32bit) and it stores an integer number between -2.147.483.648 to 2.147.483.647 .",
    "Syn": {
      "Syntax": "int var = val;",
      "Params": ["var : your int variable name<br>val : the value you assign to that variable"],
      "Return": " "
    },
    "Examples": ["int ledPin = 13;"],
    "Additional": ["long","unsignedLong","unsignedInt","byte","float","double","short"]
  },
  {
    "Name": "word",
    "Desc": "Datatype 'word'occupies two byte (16 bit) and it stores an integer number between 0 to 65535 as an 'unsigned int'.",
    "Syn": {
      "Syntax": " ",
      "Params": [" "],
      "Return": " "
    },
    "Examples": ["word w = 10000;"],
    "Additional": ["long","unsignedLong","int","unsignedInt","byte","float","double","short"]
  },
  {
    "Name": "long",
    "Desc": "Datatype 'long' occupies four byte(32bit) and it stores an integer number between -2.147.483.648 and 2.147.483.647.",
    "Syn": {
      "Syntax": "long var = val;",
      "Params": [" "],
      "Return": " "
    },
    "Examples": ["long speedOfLight = 186000L;"],
    "Additional": ["word","unsignedLong","int","unsignedInt","byte","float","double","short"]
  },
  {
    "Name": "short",
    "Desc": "Datatype 'short' occupies two byte(16 bit)and it stores an integer number between -32768 to 32767.",
    "Syn": {
      "Syntax": "short var = val;",
      "Params": ["var : your short variable name<br>val : the value you assign to that variable"],
      "Return": " "
    },
    "Examples": ["short ledPin = 13;"],
    "Additional": ["word","unsignedLong","int","unsignedInt","byte","float","double","long"]
  },
  {
    "Name": "float",
    "Desc": "Float is used to declare floating-point numbers (decimal number). They are useful because they have greater resolution than integers. <br> They are stored as 32 bits (4 bytes), so they can be as large as 3.4028235E+38 and as low as -3.4028235E+38.",
    "Syn": {
      "Syntax": "float var = val;",
      "Params": ["var - your float variable name<br>val - the value you assign to that variable"],
      "Return": " "
    },
    "Examples": ["float sensorCalbrate = 1.117;"],
    "Additional": ["word","unsignedLong","int","unsignedInt","byte","short","double","long"]
  },
  {
    "Name": "double",
    "Desc": "Double precision floating point number. On the Uno and other ATMEGA based boards, this occupies 4 bytes. That is, the double implementation is exactly the same as the float, with no gain in precision.<br> On the Arduino Due, doubles have 8-byte (64 bit) precision.",
    "Syn": {
      "Syntax": " ",
      "Params": [" "],
      "Return": " "
    },
    "Examples": [" "],
    "Additional": ["word","unsignedLong","int","unsignedInt","byte","short","float","long"]
  },
  {
    "Name": "string",
    "Desc": "The text can be represented in two ways : you can use the String data type or array of characters. See more details on www.arduino.org",
    "Syn": {
      "Syntax": "Text strings can be represented in two ways. you can use the String data type, which is part of the core as of version 0019, or you can make a string out of an array of type char and null-terminate it. This page described the latter method. For more details on the String object, which gives you more functionality at the cost of more memory, see the String object page.",
      "Params": [" "],
      "Return": " "
    },
    "Examples": ["char Str4[ ] = \"arduino\";"],
    "Additional": ["Array","PROGMEM","StringObject"]
  },
  {
    "Name": "String",
    "Desc": "The class String includes methods for examining individual characters, comparing strings, searching strings, extracting parts of strings, and for converting an entire string uppercase and lowercase. Strings are always defined inside double quotes (\"Abc\") and characters are always defined inside single quotes('A').",
    "Syn": {
      "Syntax": " ",
      "Params": [" "],
      "Return": " "
    },
    "Examples": [" "],
    "Additional": ["String","Comparison+Operators"]
  },
  {
    "Name": "char()",
    "Desc": "Converts a primitive datatype to a numeric character representation. This equivalent to the cast operator (char).",
    "Syn": {
      "Syntax": "char(x)",
      "Params": ["x: a value of any type"],
      "Return": "char"
    },
    "Examples": [" "],
    "Additional": ["unsignedChar","byte","Array"]
  },
  {
    "Name": "byte()",
    "Desc": "Converts a primitive datatype to its byte representation. This equivalent to the cast operator (byte).",
    "Syn": {
      "Syntax": "byte(x)",
      "Params": ["x: a value of any type"],
      "Return": "byte"
    },
    "Examples": [" "],
    "Additional": ["char","unsignedChar","int","unsignedInt","long","unsignedLong","float","double","array","short"]
  },
  {
    "Name": "int()",
    "Desc": "Converts a primitive datatype to its integer representation. This equivalent to the cast operator (int).",
    "Syn": {
      "Syntax": "int(x)",
      "Params": ["x: a value of any type"],
      "Return": "int"
    },
    "Examples": [" "],
    "Additional": ["char","unsignedChar","byte","unsignedInt","long","unsignedLong","float","double","array","short"]
  },
  {
    "Name": "float()",
    "Desc": "Converts a primitive datatype to its float representation. This equivalent to the cast operator (float).",
    "Syn": {
      "Syntax": "float(x)",
      "Params": ["x: a value of any type"],
      "Return": "float"
    },
    "Examples": [" "],
    "Additional": ["char","unsignedChar","byte","unsignedInt","long","unsignedLong","int","double","array","short"]
  },
  {
    "Name": "static",
    "Desc": "The static keyword is used to create variables that are visible to only one function. However unlike local variables that get created and destroyed every time a function is called, static variables persist beyond the function call, preserving their data between function calls.<br> Variables declared as static will only be created and initialized the first time a function is called.",
    "Syn": {
      "Syntax": " ",
      "Params": [" "],
      "Return": " "
    },
    "Examples": ["static int  place;"],
    "Additional": [" "]
  },
  {
    "Name": "volatile",
    "Desc": "The volatile keyword known as a variable qualifier, it is usually used before the datatype of a variable, to modify the way in which the compiler and subsequent program treats the variable.<br>Declaring a variable volatile is a directive to the compiler. The compiler is software which translates your C/C++ code into the machine code, which are the real instructions for the Atmega chip in the Arduino.<br>Specifically, it directs the compiler to load the variable from RAM and not from a storage register, which is a temporary memory location where program variables are stored and manipulated. Under certain conditions, the value for a variable stored in registers can be inaccurate.<br>A variable should be declared volatile whenever its value can be changed by something beyond the control of the code section in which it appears, such as a concurrently executing thread. In the Arduino, the only place that this is likely to occur is in sections of code associated with interrupts, called an interrupt service routine.",
    "Syn": {
      "Syntax": " ",
      "Params": [" "],
      "Return": " "
    },
    "Examples": ["volatile int state = LOW;"],
    "Additional": ["static"]
  },
  {
    "Name": "const",
    "Desc": "The const keyword stands for constant. It is a variable qualifier that modifies the behavior of the variable, making a variable \"read-only\". This means that the variable can be used just as any other variable of its type, but its value cannot be changed. You will get a compiler error if you try to assign a value to a const variable.<br>Constants defined with the const keyword obey the rules of variable scoping that govern other variables. This, and the pitfalls of using#define, makes the const keyword a superior method for defining constants and is preferred over using #define.",
    "Syn": {
      "Syntax": " ",
      "Params": [" "],
      "Return": " "
    },
    "Examples": ["const float pi = 3.14;"],
    "Additional": [" "]
  },
  {
    "Name": "define",
    "Desc": "Allows the programmer to give a name to a constant value before the program is compiled.<br> In general, the const keyword is preferred for defining constants and should be used instead of #define.",
    "Syn": {
      "Syntax": " ",
      "Params": [" "],
      "Return": " "
    },
    "Examples": ["#define ledPin 3"],
    "Additional": [" "]
  },
  {
    "Name": "sizeof",
    "Desc": "The sizeof operator returns the number of bytes in a variable type, or the number of bytes occupied by an array.",
    "Syn": {
      "Syntax": "sizeof(variable)",
      "Params": ["variable: any variable type or array (e.g. int, float, byte)"],
      "Return": " "
    },
    "Examples": ["for (i = 0; i < sizeof(ARRAY) - 1; i++) {<br>&emsp;&nbsp;//your code here<br>}"],
    "Additional": [" "]
  },
{
    "Name": "PROGMEM",
    "Desc": "Store data in flash (program) memory instead of SRAM. There's a description of the various types of memory available on an Arduino board.<br>The PROGMEM keyword is a variable modifier, it should be used only with the datatypes defined in pgmspace.h. It tells the compiler \"put this information into flash memory\", instead of into SRAM, where it would normally go.<br>PROGMEM is part of the pgmspace.h library. So you first need to include the library at the top your sketch, like this:<br>#include <avr/pgmspace.h>",
    "Syn": {
      "Syntax": "dataType variableName[] PROGMEM = {dataInt0, dataInt1, dataInt3...};<br>program memory dataType - any program memory variable type (see below)<br>variableName - the name for your array of data<br>Note that because PROGMEM is a variable modifier, there is no hard and fast rule about where it should go, so the Arduino compiler accepts all of the definitions below, which are also synonymous. However experiments have indicated that, in various versions of Arduino (having to do with GCC version), PROGMEM may work in one location and not in another. The \"string table\" example below has been tested to work with Arduino 13. Earlier versions of the IDE may work better if PROGMEM is included after the variable name.<br>dataType variableName[] PROGMEM = {};   // use this form<br>dataType PROGMEM variableName[] = {};   // not this one<br>PROGMEM  dataType  variableName[] = {}; // use this form",
      "Params": [" "],
      "Return": " "
    },
    "Examples": [" "],
    "Additional": ["Array","String"]
  },
  {
    "Name": "digitalWrite",
    "Desc": "DigitalWrite() sets 'HIGH' or 'LOW' the value of a digital output pin.<br> ",
    "Syn": {
      "Syntax": "digitalWrite(pin, value)",
      "Params": ["pin: the pin number<br>value: HIGH or LOW"],
      "Return": "none"
    },
    "Examples": ["digitalWrite(ledPin, HIGH);"],
    "Additional": ["Constants","DigitalRead","PinMode"]
  },
  {
    "Name": "digitalRead",
    "Desc": "DigitalRead reads the value of specified digital input pin.<br> The possible values are HIGH(1) or LOW (0).",
    "Syn": {
      "Syntax": "digitalRead(pin)",
      "Params": ["pin: the number of the digital pin you want to read (int)"],
      "Return": "HIGH or LOW"
    },
    "Examples": ["val = digitalRead(PIN);"],
    "Additional": ["Constants","DigitalWrite","PinMode"]
  },
  {
    "Name": "analogReference",
    "Desc": "The analogReference() method sets the mode for assigning the voltage used as reference for the analogRead() command, this value will be the maximum voltage used as reference.<br> The options are:<br>DEFAULT: the default analog reference are 5V or 3.3V; <br> INTERNAL: an built-in reference, equal to 1.1 volts on the ATmega168 or ATmega328 and 2.56 volts on the ATmega8;<br> INTERNAL1V1: built-in 1.1V reference;<br> INTERNAL2V56: built-in 2.56V reference;<br> EXTERNAL: use as reference the voltage applied to AREF pin in the range 0-5V only. .",
    "Syn": {
      "Syntax": "analogReference(type)",
      "Params": ["type: which type of reference to use (DEFAULT, INTERNAL, INTERNAL1V1, INTERNAL2V56, or EXTERNAL)."],
      "Return": "none"
    },
    "Examples": [" "],
    "Additional": ["AnalogRead","AnalogWrite","AnalogReadResolution","AnalogWriteResolution"]
  },
  {
    "Name": "analogRead",
    "Desc": "AnalogRead reads the value of an analog input pin.<br> The possible values are including between 0 and 1023, where 0 is 0 volt and 1023 equals 5 volts.<br> Generally the resolution is 4,9mV for unit but it can be changed using analogReference.",
    "Syn": {
      "Syntax": "analogRead(pin)",
      "Params": ["pin: the number of the analog input pin to read from (0 to 5 on most boards, 0 to 7 on the Mini and Nano, 0 to 15 on the Mega)"],
      "Return": "int (0 to 1023)"
    },
    "Examples": ["val = analogRead(analogPin);"],
    "Additional": ["AnalogReference","AnalogWrite","AnalogReadResolution","AnalogWriteResolution"]
  },
  {
    "Name": "analogWrite",
    "Desc": "Writes an analog value (PWM wave) to a pin.<br> The frequency of the PWM signal on most pins is approximately 490Hz. On the Uno and similar boards, pins 5 and 6 have a frequency of approximately 980Hz. Pins 3 and 11 on the Leonardo also run at 980Hz.<br> On most Arduino boards (those with the ATmega168 or ATmega328), this function works on pins 3, 5, 6, 9, 10, and 11. On the Arduino Mega, it works on pins 2 - 13 and 44 - 46. Older Arduino boards with an ATmega8 only support analogWrite() on pins 9, 10, and 11.<br> The possible values are between 0 to 255.",
    "Syn": {
      "Syntax": "analogWrite(pin, value)",
      "Params": ["pin: the pin to write to.<br>value: the duty cycle: between 0 (always off) and 255 (always on)."],
      "Return": "none"
    },
    "Examples": ["analogWrite(ledPin, 125);"],
    "Additional": ["AnalogRead","AnalogReference","AnalogReadResolution","AnalogWriteResolution"]
  },
  {
    "Name": "analogReadResolution",
    "Desc": "analogReadResolution() is an extension of the Analog API for the Arduino Due.<br>Sets the size (in bits) of the value returned by analogRead(). It defaults to 10 bits (returns values between 0-1023) for backward compatibility with AVR based boards.<br>The Due has 12-bit ADC capabilities that can be accessed by changing the resolution to 12. This will return values from analogRead() between 0 and 4095.",
    "Syn": {
      "Syntax": "analogReadResolution(bits)",
      "Params": ["bits: determines the resolution (in bits) of the value returned by analogRead() function. You can set this 1 and 32. You can set resolutions higher than 12 but values returned by analogRead() will suffer approximation. See the note below for details."],
      "Return": "none"
    },
    "Examples": ["analogReadResolution(10);"],
    "Additional": ["AnalogReference","AnalogRead","AnalogWrite","AnalogWriteResolution"]
  },
  {
    "Name": "analogWriteResolution",
    "Desc": "analogWriteResolution() is an extension of the Analog API for the Arduino Due.<br>analogWriteResolution() sets the resolution of the analogWrite() function. It defaults to 8 bits (values between 0-255) for backward compatibility with AVR based boards.<br>The Due has the following hardare capabilities:<br>12 pins which default to 8-bit PWM, like the AVR-based boards. These can be changed to 12-bit resolution.<br>2 pins with 12-bit DAC (Digital-to-Analog Converter)<br>By setting the write resolution to 12, you can use analogWrite() with values between 0 and 4095 to exploit the full DAC resolution or to set the PWM signal without rolling over.",
    "Syn": {
      "Syntax": "analogWriteResolution(bits)",
      "Params": ["bits: determines the resolution (in bits) of the values used in the analogWrite() function. The value can range from 1 to 32. If you choose a resolution higher or lower than your board's hardware capabilities, the value used in analogWrite() will be either truncated if it's too high or padded with zeros if it's too low. See the note below for details."],
      "Return": "none"
    },
    "Examples": ["  analogWriteResolution(8);"],
    "Additional": ["AnalogReference","AnalogRead","AnalogWrite","AnalogReadResolution"]
  },
  {
    "Name": "tone",
    "Desc": "The tone() function is used to generate a determined frequency for an amount of time on a pin. <br> The function can express one tone at a time. If a tone is alredy playing on a different pin, a new tone function won't have effect. If the tone is playing on the same pin, the call will set its frequency.",
    "Syn": {
      "Syntax": "tone(pin, frequency)<br>tone(pin, frequency, duration)",
      "Params": ["pin: the pin on which to generate the tone<br>frequency: the frequency of the tone in hertz - unsigned int<br>duration: the duration of the tone in milliseconds (optional) - unsigned long"],
      "Return": "none"
    },
    "Examples": [" "],
    "Additional": ["NoTone"]
  },
  {
    "Name": "shiftOut",
    "Desc": "The shiftOut() function writes data on a pin, one bit at a time.<br> It can write bits starting from the most or the least significant bit (leftmost or rightmost bit).",
    "Syn": {
      "Syntax": "shiftOut(dataPin, clockPin, bitOrder, value)",
      "Params": ["dataPin: the pin on which to output each bit (int)<br>clockPin: the pin to toggle once the dataPin has been set to the correct value (int)<br>bitOrder: which order to shift out the bits; either MSBFIRST or LSBFIRST.<br>(Most Significant Bit First, or, Least Significant Bit First)<br>value: the data to shift out. (byte)"],
      "Return": "none"
    },
    "Examples": ["shiftOut(dataPin, clock, LSBFIRST, data);"],
    "Additional": ["ShiftIn"]
  },
  {
    "Name": "noTone",
    "Desc": "The noTone() function stops the generation of a frequency in a specified pin.",
    "Syn": {
      "Syntax": "noTone(pin)",
      "Params": ["pin: the pin on which to stop generating the tone"],
      "Return": "none"
    },
    "Examples": [" "],
    "Additional": ["Tone"]
  },
  {
    "Name": "shiftIn",
    "Desc": "The shiftOut() function reads data on a pin, one bit at a time.<br> It can read bits starting from the most or the least significant bit (leftmost or rightmost bit).",
    "Syn": {
      "Syntax": "byte incoming = shiftIn(dataPin, clockPin, bitOrder)",
      "Params": ["dataPin: the pin on which to input each bit (int)<br>clockPin: the pin to toggle to signal a read from dataPin<br>bitOrder: which order to shift in the bits; either MSBFIRST or LSBFIRST.<br>(Most Significant Bit First, or, Least Significant Bit First)"],
      "Return": "the value read (byte)"
    },
    "Examples": [" "],
    "Additional": ["ShiftOut"]
  },
  {
    "Name": "pulseIn",
    "Desc": "This function reads a pulse on a pin. It can read a pulse either HIGH or LOW on a pin.<br> If value is HIGH, pulseIn() waits for the pin to go HIGH, starts timing, then waits for the pin to go LOW and stops timing.<br> Returns the length of the pulse in microseconds. if no pulse starts within a specified time out it stops and returns 0..",
    "Syn": {
      "Syntax": "pulseIn(pin, value)<br>pulseIn(pin, value, timeout)",
      "Params": ["pin: the number of the pin on which you want to read the pulse. (int)<br>value: type of pulse to read: either HIGH or LOW. (int)<br>timeout (optional): the number of microseconds to wait for the pulse to start; default is one second (unsigned long)"],
      "Return": "the length of the pulse (in microseconds) or 0 if no pulse started before the timeout (unsigned long)"
    },
    "Examples": ["duration = pulseIn(pin, HIGH);"],
    "Additional": [" "]
  },
  {
    "Name": "millis",
    "Desc": "It is used to get the time in milliseconds since the program started.<br> It returns a unsigned long.",
    "Syn": {
      "Syntax": "millis();",
      "Params": ["None"],
      "Return": "Number of milliseconds since the program started (unsigned long)"
    },
    "Examples": ["time = millis();"],
    "Additional": [" "]
  },
  {
    "Name": "micros",
    "Desc": "This function returns the number of microseconds since the current program started. <br> It resets every about 70 minutes. <br> The resolution of microseconds is different for each Arduino board in use.",
    "Syn": {
      "Syntax": "micros();",
      "Params": ["none"],
      "Return": "Number of microseconds since the program started (unsigned long)"
    },
    "Examples": ["time = micros();"],
    "Additional": ["Millis"]
  },
  {
    "Name": "delay",
    "Desc": "This function pauses the program for a specified amount of time, expressex in milliseconds.",
    "Syn": {
      "Syntax": "delay(ms);",
      "Params": ["ms: the number of milliseconds to pause (unsigned long)"],
      "Return": "none"
    },
    "Examples": ["delay(1000); //delays one second"],
    "Additional": ["DelayMicroseconds"]
  },
  {
    "Name": "delayMicroseconds",
    "Desc": "This function pauses the program for a specified amount of time, expressex in microseconds.",
    "Syn": {
      "Syntax": "delayMicroseconds(us);",
      "Params": ["us: the number of microseconds to pause (unsigned int)"],
      "Return": "none"
    },
    "Examples": ["  delayMicroseconds(50); //pauses for 50"],
    "Additional": ["Delay"]
  },
  {
    "Name": "min",
    "Desc": "Calculates the minimum of two numbers.",
    "Syn": {
      "Syntax": "min(x, y)",
      "Params": ["x: the first number, any data type<br>y: the second number, any data type"],
      "Return": "The smaller of the two numbers."
    },
    "Examples": ["sensVal = min(sensVal, 100);"],
    "Additional": ["Max"]
  },
  {
    "Name": "max",
    "Desc": "Calculates the maximum of two numbers.",
    "Syn": {
      "Syntax": "max(x, y)",
      "Params": ["x: the first number, any data type<br>y: the second number, any data type"],
      "Return": "The larger of the two parameter values."
    },
    "Examples": ["sensVal = max(senVal, 20);"],
    "Additional": ["Min"]
  },
  {
    "Name": "abs",
    "Desc": "Computes the absolute value of a number.",
    "Syn": {
      "Syntax": "abs(x)",
      "Params": ["x: the number"],
      "Return": "x: if x is greater than or equal to 0.<br>-x: if x is less than 0."
    },
    "Examples": ["abs(a);"],
    "Additional": ["Constrain"]
  },
  {
    "Name": "constrain",
    "Desc": "Constrains a number to be within a range.",
    "Syn": {
      "Syntax": "constrain(x, a, b)",
      "Params": ["x: the number to constrain, all data types<br>a: the lower end of the range, all data types<br>b: the upper end of the range, all data types"],
      "Return": "x: if x is between a and b<br>a: if x is less than a<br>b: if x is greater than b"
    },
    "Examples": ["sensVal = constrain(sensVal, 10, 150);"],
    "Additional": ["Abs","Map"]
  },
  {
    "Name": "map",
    "Desc": "Re-maps a number from one range to another. That is, a value of fromLow would get mapped to toLow, a value of fromHigh to toHigh, values in-between to values in-between, etc.<br>Does not constrain values to within the range, because out-of-range values are sometimes intended and useful. The constrain() function may be used either before or after this function, if limits to the ranges are desired.<br>Note that the \"lower bounds\" of either range may be larger or smaller than the \"upper bounds\" so the map() function may be used to reverse a range of numbers, for example<br>y = map(x, 1, 50, 50, 1);<br>The function also handles negative numbers well, so that this example<br>y = map(x, 1, 50, 50, -100);<br>is also valid and works well.<br>The map() function uses integer math so will not generate fractions, when the math might indicate that it should do so. Fractional remainders are truncated, and are not rounded or averaged.",
    "Syn": {
      "Syntax": "map(value, fromLow, fromHigh, toLow, toHigh)",
      "Params": ["value: the number to map<br>fromLow: the lower bound of the value's current range<br>fromHigh: the upper bound of the value's current range<br>toLow: the lower bound of the value's target range<br>toHigh: the upper bound of the value's target range"],
      "Return": "The mapped value."
    },
    "Examples": ["val = map(val, 0, 1023, 0, 255);"],
    "Additional": ["Constrain"]
  },
  {
    "Name": "pow",
    "Desc": "Calculates the value of a number raised to a power. Pow() can be used to raise a number to a fractional power. This is useful for generating exponential mapping of values or curves.",
    "Syn": {
      "Syntax": "pow(base, exponent);",
      "Params": ["base: the number (float)<br>exponent: the power to which the base is raised (float)"],
      "Return": "The result of the exponentiation (double)"
    },
    "Examples": [" "],
    "Additional": ["Sqrt","Float","Double"]
  },
  {
    "Name": "sqrt",
    "Desc": "Calculates the square root of a number.",
    "Syn": {
      "Syntax": "sqrt(x);",
      "Params": ["x: the number, any data type"],
      "Return": "double, the number's square root."
    },
    "Examples": [" "],
    "Additional": ["Pow"]
  },
  {
    "Name": "sin",
    "Desc": "Calculates the sine of an angle in radians (the radians value are between 0 and 6,28). The result will be between -1 and 1.",
    "Syn": {
      "Syntax": "sin(rad)",
      "Params": ["rad: the angle in radians (float)"],
      "Return": "the sine of the angle (double)"
    },
    "Examples": [" "],
    "Additional": ["Cos","Tan"]
  },
  {
    "Name": "cos",
    "Desc": "Calculates the cos of an angle (in radians). The result will be between -1 and 1.",
    "Syn": {
      "Syntax": "cos(rad)",
      "Params": ["rad: the angle in radians (float)"],
      "Return": "The cos of the angle (\"double\")"
    },
    "Examples": [" "],
    "Additional": ["Sin","Tan"]
  },
  {
    "Name": "tan",
    "Desc": "Calculates the tangent of an angle (in radians). The result will be between negative infinity and infinity.",
    "Syn": {
      "Syntax": "tan(rad)",
      "Params": ["rad: the angle in radians (float)"],
      "Return": "The tangent of the angle (double)"
    },
    "Examples": [" "],
    "Additional": ["Cos","Sin"]
  },
  {
    "Name": "randomSeed",
    "Desc": "Sets the seed value for random(). By default, random() produces different results each time the program is run. Set the value parameter to a constant to return the same pseudo-random numbers each time the software is run.",
    "Syn": {
      "Syntax": "randomSeed(seed)",
      "Params": ["long, int - pass a number to generate the seed."],
      "Return": "none"
    },
    "Examples": ["randomSeed(analogRead(0));"],
    "Additional": ["Random"]
  },
  {
    "Name": "random",
    "Desc": "Generates random numbers. Each time the random() function is called, it returns an unexpected value within the specified range. If one parameter is passed to the function it will return a float between zero and the value of the parameter. The function call random(5) returns values between 0 and 5. If two parameters are passed, it will return a float with a value between the the parameters.",
    "Syn": {
      "Syntax": "random(max);<br>random(min, max);",
      "Params": ["min - lower bound of the random value, inclusive (optional)<br>max - upper bound of the random value, exclusive"],
      "Return": "a random number between min and max-1 (long)"
    },
    "Examples": ["randNumber = random(300);"],
    "Additional": ["RandomSeed"]
  },
  {
    "Name": "lowByte",
    "Desc": "ELowByte returns the low Byte(that is righmost) of a variable(e.g. a word).",
    "Syn": {
      "Syntax": "lowByte(x);",
      "Params": ["x: a value of any type"],
      "Return": "byte"
    },
    "Examples": [" "],
    "Additional": ["HighByte","Bit","BitRead","BitWrite","BitSet","BitClear"]
  },
  {
    "Name": "highByte",
    "Desc": "HighByte returns the higher Byte(that is leftmost) of a variable to 2byte(16bit) or the second lowest byte of a larger data type.",
    "Syn": {
      "Syntax": "highByte(x);",
      "Params": ["x: a value of any type"],
      "Return": "byte"
    },
    "Examples": [" "],
    "Additional": ["LowByte","Bit","BitRead","BitWrite","BitSet","BitClear"]
  },
  {
    "Name": "bitRead",
    "Desc": "This command reads a determined bit of a number.",
    "Syn": {
      "Syntax": "bitRead(x);",
      "Params": ["x: the number from which to read<br>n: which bit to read, starting at 0 for the least-significant (rightmost) bit"],
      "Return": "the value of the bit (0 or 1)."
    },
    "Examples": [" "],
    "Additional": ["HighByte","LowByte","Bit","BitWrite","BitSet","BitClear"]
  },
  {
    "Name": "bitWrite",
    "Desc": "This command writes a determined bit of a number.",
    "Syn": {
      "Syntax": "bitWritex, n, b);",
      "Params": ["x: the numeric variable to which to write<br>n: which bit of the number to write, starting at 0 for the least-significant (rightmost) bit<br>b: the value to write to the bit (0 or 1)"],
      "Return": "none"
    },
    "Examples": [" "],
    "Additional": ["HighByte","LowByte","Bit","BitRead","BitSet","BitClear "]
  },
  {
    "Name": "bitSet",
    "Desc": "BitSet sets to 1 a determined bit of a number.",
    "Syn": {
      "Syntax": "bitSet(x, n);",
      "Params": ["x: the numeric variable whose bit to set<br>n: which bit to set, starting at 0 for the least-significant (rightmost) bit"],
      "Return": "none"
    },
    "Examples": [" "],
    "Additional": ["HighByte","LowByte","Bit","BitWrite","BitRead","BitClear "]
  },
  {
    "Name": "bitClear",
    "Desc": "BitSet clear (writes a 0 to)a determined bit of a number.",
    "Syn": {
      "Syntax": "bitClear(x, n)",
      "Params": ["x: the numeric variable whose bit to clear<br>n: which bit to clear, starting at 0 for the least-significant (rightmost) bit"],
      "Return": "none"
    },
    "Examples": [" "],
    "Additional": ["HighByte","LowByte","Bit","BitRead","BitWrite","BitSet"]
  },
  {
    "Name": "bit",
    "Desc": "CThe bit() command computes the value of a determined bit.",
    "Syn": {
      "Syntax": "bit(n);",
      "Params": ["n: the bit whose value to compute"],
      "Return": "the value of the bit"
    },
    "Examples": [" "],
    "Additional": ["HighByte","LowByte","BitClear","BitRead","BitWrite","BitSet"]
  },
  {
    "Name": "detachInterrupt",
    "Desc": "DetachInterrupt() method disables a specific interrupt.",
    "Syn": {
      "Syntax": "detachInterrupt(interrupt)<br>detachInterrupt(pin)",
      "Params": ["interrupt: the number of the interrupt to disable (see attachInterrupt() for more details).<br>pin: the pin number of the interrupt to disable (Arduino Due only)"],
      "Return": " "
    },
    "Examples": [" "],
    "Additional": ["AttachInterrupt","Interrupt","NoInterrupt"]
  },
  {
    "Name": "attachInterrupt",
    "Desc": "This command specifies a named Interrupt Service Routine (ISR) to call when an interrupt occurs.<br> Most Arduino boards have two external interrupts: int. 0 (on digital pin 2) and int.1 (on digital pin 3).<br> There are some Arduino board that have others interrupt.",
    "Syn": {
      "Syntax": "attachInterrupt(interrupt,function, mode)<br>attachInterrupt(pin,ISR, mode) (Arduino Due only)",
      "Params": ["interrupt: the number of the external interrupt to enable.<br> pin: the pin number of the interrupt to enable<br> ISR: the name of the function to be called whenever the interrupt event happens. This function must take no parameters and return nothing.<br>mode: there are four valid mode: LOW, CHANGE, RISING, FALLING. <br>(for more details www.arduino.org)"],
      "Return": ""
    },
    "Examples": [""],
    "Additional": ["DetachInterrupt","Interrupt","NoInterrupt"]
  },
  {
    "Name": "interrupts",
    "Desc": "Interrupts()method enables the interrupts, after it has been disabled by noInterrupts().<br> By default interruptions are enabled to allow important tasks to happen in the background.<br> Some functions will not work while interrupts are disabled, and incoming communication may be ignored.<br> The interrupts may be disabled for particularly critical sections of code.",
    "Syn": {
      "Syntax": " ",
      "Params": ["none"],
      "Return": "none"
    },
    "Examples": [" "],
    "Additional": ["AttachInterrupt","DetachInterrupt","NoInterrupt"]
  },
  {
    "Name": "noInterrupts",
    "Desc": "NoInterrupts()method disables the interrupts.<br> By default interruptions are enabled to allow important tasks to happen in the background.<br> Some functions will not work while interrupts are disabled, and incoming communication may be ignored.<br> The interrupts may be disabled for particularly critical sections of code.<br> After disabling interrupts it is necessary to re-enable them or all other I/O activities will not work again in the current program.",
    "Syn": {
      "Syntax": " ",
      "Params": ["none"],
      "Return": "none"
    },
    "Examples": [" "],
    "Additional": ["AttachInterrupt","DetachInterrupt","Interrupt"]
  }
]